{"version":3,"file":"index.module.js","sources":["../src/Node.js","../src/prepend.js","../src/merge.js","../src/mergepairs.js","../src/decreasekey.js","../src/PairingHeap.js"],"sourcesContent":["export default class Node {\n\tconstructor(value) {\n\t\tthis.value = value; // Key\n\t\tthis.prev = null; // Pointer to previous sibling\n\t\tthis.next = null; // Pointer to next sibling\n\t\tthis.children = new Beginning(); // Pointer to children list\n\t\t// first child is this.children.next\n\t}\n}\n\n/**\n * Avoids if-then-else logic when manipulating child nodes\n */\nexport class Beginning {\n\tconstructor() {\n\t\tthis.next = null;\n\t}\n}\n\n// Export class End {\n// constructor (prev) {\n// this.prev = prev;\n// }\n// }\n","/**\n * Set B as the first child of A.\n *\n * /!\\ Precondition:\n *   1. A != null\n *   2. B != null\n *   3. A.next = A.prev = B.next = B.prev = null\n *\n * @param {Node} A\n * @param {Node} B\n * @return {Node} The input node A with .next = .prev = null.\n */\nexport default function prepend(A, B) {\n\tB.prev = A.children;\n\tB.next = A.children.next;\n\tA.children.next = B;\n\n\tif (B.next !== null) B.next.prev = B;\n\n\treturn A;\n}\n","import prepend from './prepend.js';\n\n/**\n * Merge: compare the two root elements, the smaller remains the root of the\n * result, the larger element and its subtree is appended as a child of this\n * root.\n *\n * /!\\ Precondition:\n *   1. A != null and A.next = A.prev = null\n *   2. B != null and B.next = B.prev = null\n *\n * @param {Function} compare Comparison functions for keys.\n * @param {Node} A The first input node.\n * @param {Node} B The second input node.\n * @returns {Node} The input node with smallest key with .next = .prev = null.\n */\nexport default function merge(compare, A, B) {\n\tif (compare(A.value, B.value) < 0) return prepend(A, B);\n\n\treturn prepend(B, A);\n}\n","import merge from './merge.js';\n\n/**\n * Recursively builds a heap from an iterator of nodes by merging them pair by\n * pair.\n *\n * @param {Function} compare Comparison function for node keys.\n * @param {Node} prev Last node before first of list. First node is `prev.next`.\n * @returns {Node} The root node with .next = .prev = null or null for an empty\n *                 iterator.\n */\nexport default function mergepairs(compare, previous) {\n\t// Unpick linked list starting at prev.next\n\n\tconst A = previous.next;\n\tprevious.next = null;\n\n\tif (A === null) return null;\n\tA.prev = null;\n\n\tconst B = A.next;\n\tA.next = null;\n\n\tif (B === null) return A;\n\tB.prev = null;\n\n\t// Recursion fairy for the rest of the heap\n\tconst tail = mergepairs(compare, B); // Sets B.next = null\n\n\t// merge A != null with B != null\n\tconst head = merge(compare, A, B); // Call to merge is valid\n\n\t// merge with the rest\n\tif (tail === null) return head;\n\n\t// Head != null, tail != null\n\treturn merge(compare, head, tail); // Also valid because tail and head\n\t// are outputs of merge{pairs}\n}\n","import merge from './merge.js';\n\n/**\n * Decrease-key: remove the subtree rooted at the key to be decreased, replace\n * the key with a smaller key, then merge the result back into the heap.\n *\n * @param {Function} compare Comparison function for keys.\n * @param {Node} min Current minimum-key node != null with .prev = .next = null.\n * @param {Node} node Node != null to update with .prev != null.\n * @param {Object} value The new value for the key of the node to update.\n * @returns {Node} Returns the node containing the minimum key.\n */\nexport default function decreasekey(compare, min, node, value) {\n\t// Update node's key\n\tnode.value = value;\n\n\t// Remove node from tree\n\tnode.prev.next = node.next; // By assumption node.prev != null\n\tif (node.next !== null) {\n\t\tnode.next.prev = node.prev;\n\t\tnode.next = null;\n\t}\n\n\tnode.prev = null;\n\n\t// Merge, remember we move the whole subtree with children\n\t// node.prev = node.next = null at this point so safe to call merge\n\t// min != null and node != null\n\treturn merge(compare, min, node);\n}\n","import merge from './merge.js';\nimport mergepairs from './mergepairs.js';\nimport decreasekey from './decreasekey.js';\nimport Node from './Node.js';\n\nexport default class PairingHeap {\n\tconstructor(compare) {\n\t\tthis.compare = compare; // Comparison function\n\t\tthis.min = null; // Root node, must have .prev = .next = null at all times\n\t}\n\n\t/**\n\t * Find-min: simply return the top element of the heap.\n\t */\n\thead() {\n\t\tif (this.min === null) return undefined;\n\t\treturn this.min.value;\n\t}\n\n\theadreference() {\n\t\treturn this.min;\n\t}\n\n\t/**\n\t * Delete-min: remove the root and merge its subtrees. Various strategies\n\t * are employed.\n\t */\n\tpop() {\n\t\tconst min = this.popreference();\n\t\treturn min === null ? undefined : min.value;\n\t}\n\n\t/**\n\t */\n\tpopreference() {\n\t\tif (this.min === null) return null;\n\t\tconst min = this.min;\n\t\tthis.min = mergepairs(this.compare, min.children); // Min.children.next = null\n\t\treturn min;\n\t}\n\n\t/**\n\t * Insert: create a new heap for the inserted element and merge into the\n\t * original heap.\n\t */\n\tpush(value) {\n\t\tconst node = new Node(value);\n\t\treturn this.pushreference(node);\n\t}\n\n\t/**\n\t * /!\\ ref.next = ref.prev = null which means all references that are\n\t * external to the tree must reset .next and .prev and one must not call\n\t * PairingHeap#pushreference with an internal reference from this tree or\n\t * another, except the root of another tree.\n\t */\n\tpushreference(ref) {\n\t\tthis.min = this.min === null ? ref : merge(this.compare, this.min, ref); // This.min != null != ref\n\t\treturn ref;\n\t}\n\n\t/**\n\t * Supposes the same comparison function is used in both trees.\n\t * We can call pushreference since other.min.next = other.min.prev = null.\n\t */\n\tmerge(other) {\n\t\tconst ref = other.min;\n\t\tif (ref !== null) this.pushreference(ref);\n\t}\n\n\t/**\n\t * @param {Node} ref Non-null internal node object.\n\t * @param {Object} value The new value for ref.\n\t */\n\tupdate(ref, value) {\n\t\tconst d = this.compare(value, ref.value);\n\n\t\tif (d < 0) this.decreasekey(ref, value);\n\t\telse if (d > 0) this.increasekey(ref, value);\n\t\telse ref.value = value;\n\t}\n\n\t/**\n\t * Decrease-key\n\t *\n\t * @param {Node} ref Non-null internal node object.\n\t * @param {Object} value The new value for ref.\n\t */\n\tdecreasekey(ref, value) {\n\t\tif (ref === this.min) ref.value = value;\n\t\telse {\n\t\t\t// This.min != null, ref != null\n\t\t\tthis.min = decreasekey(this.compare, this.min, ref, value);\n\t\t}\n\t}\n\n\t/**\n\t * Increase-key: remove the item at the key to be increased, replace\n\t * the key with a larger key, then push the result back into the heap.\n\t *\n\t * @param {Node} ref Non-null internal node object.\n\t * @param {Object} value The new value for ref.\n\t *\n\t */\n\tincreasekey(ref, value) {\n\t\tthis.delete(ref);\n\n\t\tref.value = value;\n\n\t\tthis.pushreference(ref);\n\t}\n\n\t/**\n\t * Ref must be internal\n\t * ref.prev and ref.next get reset to null\n\t */\n\tdelete(ref) {\n\t\tif (ref === this.min) {\n\t\t\tthis.popreference();\n\t\t\treturn;\n\t\t}\n\n\t\tconst successor = mergepairs(this.compare, ref.children); // Ref.children.next = null\n\n\t\t// ref has no children\n\t\tif (successor === null) {\n\t\t\t//  _       _       _\n\t\t\t// | | --> | | --> | |\n\t\t\t// |_| <-- |_| <-- |_|\n\t\t\t//  P       R       N\n\n\t\t\t// detach ref and link ref.prev to ref.next\n\t\t\t//\n\t\t\t//  _               _\n\t\t\t// | | ----------> | |\n\t\t\t// |_| <    _   -> |_|\n\t\t\t//  P   \\  | | /  / N\n\t\t\t//       - |_| <-/\n\t\t\t//          R\n\t\t\t//\n\t\t\tref.prev.next = ref.next; // Must be != null because ref != min\n\n\t\t\tif (ref.next !== null) {\n\t\t\t\t//\n\t\t\t\t//  _               _\n\t\t\t\t// | | ----------> | |\n\t\t\t\t// |_| <---------- |_|\n\t\t\t\t//  P       _       N\n\t\t\t\t//  ^      | | -----^\n\t\t\t\t//  |----- |_|\n\t\t\t\t//          R\n\t\t\t\t//\n\t\t\t\tref.next.prev = ref.prev;\n\t\t\t\t//\n\t\t\t\t//  _               _\n\t\t\t\t// | | ----------> | |\n\t\t\t\t// |_| <---------- |_|\n\t\t\t\t//  P       _       N\n\t\t\t\t//  ^      | |\n\t\t\t\t//  |----- |_|\n\t\t\t\t//          R\n\t\t\t\t//\n\t\t\t\tref.next = null;\n\t\t\t}\n\n\t\t\t//\n\t\t\t//  _               _\n\t\t\t// | | ----------> | |\n\t\t\t// |_| <---------- |_|\n\t\t\t//  P       _       N\n\t\t\t//         | |\n\t\t\t//         |_|\n\t\t\t//          R\n\t\t\t//\n\t\t\tref.prev = null;\n\n\t\t\treturn;\n\t\t}\n\n\t\tsuccessor.prev = ref.prev; // Must be != null because ref != min\n\t\tsuccessor.prev.next = successor;\n\t\tref.prev = null;\n\n\t\tif (ref.next !== null) {\n\t\t\tsuccessor.next = ref.next; // Might be null\n\t\t\tsuccessor.next.prev = successor;\n\t\t\tref.next = null;\n\t\t}\n\t}\n}\n"],"names":["Node","value","this","prev","next","children","Beginning","prepend","A","B","merge","compare","mergepairs","previous","tail","head","decreasekey","min","node","PairingHeap","headreference","pop","popreference","undefined","push","pushreference","ref","other","update","d","increasekey","delete","successor"],"mappings":"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"}