import{min as t}from"@iterable-iterator/reduce";import{prop as e}from"@total-order/key";import{decreasing as o,increasing as r}from"@total-order/primitive";import{list as n}from"@iterable-iterator/list";import{map as s}from"@iterable-iterator/map";import{PairingHeap as i}from"@heap-data-structure/pairing-heap";import{head as f}from"@iterable-iterator/slice";function c(t){const e=new Map;for(const[o,r]of t)e.has(o)||e.set(o,[]),e.get(o).push(r),e.has(r)||e.set(r,[]),e.get(r).push(o);return e}function a(t,e){const o=e[e.length-2],r=e[e.length-1],n=new Map;for(const s of f(e,-2)){const e=[];n.set(s,e);for(const n of t.get(s))e.push(n===r?o:n)}const s=[];n.set(o,s);for(const e of t.get(o))e!==r&&s.push(e);for(const e of t.get(r))e!==o&&e!==r&&s.push(e);return n}function*p(t){const r=new i(e(o,"weight")),n=new Map;for(const e of t.keys())n.set(e,r.push({weight:0,vertex:e}));for(const e of t){const e=r.pop(),o=e.vertex;yield[o,e.weight],n.delete(o);for(const e of t.get(o)){if(!n.has(e))continue;const t=n.get(e);r.decreasekey(t,{weight:t.value.weight+1,vertex:t.value.vertex})}}}function u(o){const i=c(o),[f]=function(o){return t(e(r,1),function*(t){let e=t;const o=new Map;for(const e of t.keys())o.set(e,[e]);for(;e.size>=2;){const t=n(p(e)),[r]=t[t.length-2],[i,f]=t[t.length-1];yield[new Set(o.get(i)),f],o.set(r,o.get(r).concat(o.get(i))),e=a(e,n(s(([t,e])=>t,t)))}}(o),void 0)}(i);return function*(t,e){for(const o of e)for(const r of t.get(o))e.has(r)||(yield[o,r])}(i,f)}export{c as adj,u as maxback,u as mincut};
//# sourceMappingURL=index.modern.js.map
