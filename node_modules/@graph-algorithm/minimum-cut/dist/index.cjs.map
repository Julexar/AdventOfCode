{"version":3,"file":"index.cjs","sources":["../src/adj.js","../src/maxback/_contract.js","../src/maxback/_order.js","../src/maxback/_smallcuts.js","../src/outgoingedges.js","../src/maxback/maxback.js","../src/maxback/mb.js"],"sourcesContent":["/**\n * Constructs the adjacency list for an undirected unweighted connected\n * loopless multigraph G given as a list of edges.\n *\n * @param {Iterable} edges The edges of G.\n * @returns {Map} The adjacency list G.\n */\nexport default function adj(edges) {\n\tconst G = new Map();\n\tfor (const [u, v] of edges) {\n\t\tif (!G.has(u)) G.set(u, []);\n\t\tG.get(u).push(v);\n\t\tif (!G.has(v)) G.set(v, []);\n\t\tG.get(v).push(u);\n\t}\n\n\treturn G;\n}\n","import {head} from '@iterable-iterator/slice';\n\n/**\n * Given G and some ordering, computes the graph H obtained from G by\n * contracting all edges between the last two vertices of the ordering.\n *\n * @param {Map} G\n * @param {Array} ordering\n * @returns {Map}\n */\nexport default function _contract(G, ordering) {\n\tconst u = ordering[ordering.length - 2];\n\tconst v = ordering[ordering.length - 1];\n\n\tconst H = new Map();\n\n\t// Replace each edge xv by the edge xu, x != u ^ x != v\n\tfor (const x of head(ordering, -2)) {\n\t\tconst n = [];\n\t\tH.set(x, n);\n\t\tfor (const y of G.get(x)) n.push(y === v ? u : y);\n\t}\n\n\tconst nx = [];\n\tH.set(u, nx);\n\t// Keep all edges ux with, x != v (x != u is implied because G is loopless)\n\tfor (const x of G.get(u)) if (x !== v) nx.push(x);\n\t// Replace each edge vx by the edge ux, x != u ^ x != v\n\tfor (const x of G.get(v)) if (x !== u && x !== v) nx.push(x);\n\treturn H;\n}\n","import {prop} from '@total-order/key';\nimport {decreasing} from '@total-order/primitive';\nimport {PairingHeap as Heap} from '@heap-data-structure/pairing-heap';\n\n/**\n * Lists the vertices of an undirected unweighted connected loopless multigraph\n * G in max-back order.\n *\n * @param {Map} G The adjacency list of G.\n * @returns {Iterable} The vertices of G in max-back order.\n */\nexport default function* _order(G) {\n\tconst heap = new Heap(prop(decreasing, 'weight'));\n\tconst refs = new Map();\n\n\tfor (const v of G.keys()) refs.set(v, heap.push({weight: 0, vertex: v}));\n\n\t// eslint-disable-next-line no-unused-vars\n\tfor (const _ of G) {\n\t\tconst max = heap.pop();\n\t\tconst u = max.vertex;\n\t\tyield [u, max.weight];\n\t\trefs.delete(u);\n\n\t\t// Update keys\n\t\tfor (const v of G.get(u)) {\n\t\t\tif (!refs.has(v)) continue;\n\t\t\tconst ref = refs.get(v);\n\t\t\t// Max heap so decrease-weight is used for +\n\t\t\theap.decreasekey(ref, {\n\t\t\t\tweight: ref.value.weight + 1,\n\t\t\t\tvertex: ref.value.vertex,\n\t\t\t});\n\t\t}\n\t}\n}\n","import {list} from '@iterable-iterator/list';\nimport {map} from '@iterable-iterator/map';\n\nimport _order from './_order.js';\nimport _contract from './_contract.js';\n\n/**\n * Yields the small cuts of undirected unweighted connected loopless multigraph G.\n * At least one of them must be a minimum cut.\n *\n * @param {Map} G The adjacency list of G.\n * @returns {Iterable} The small cuts of G.\n */\nexport default function* _smallcuts(G) {\n\tlet H = G;\n\tconst id = new Map();\n\tfor (const v of G.keys()) id.set(v, [v]);\n\n\twhile (H.size >= 2) {\n\t\tconst ordering = list(_order(H)); // Compute the max-back order\n\t\tconst [x] = ordering[ordering.length - 2];\n\t\tconst [y, cutsize] = ordering[ordering.length - 1];\n\n\t\tyield [new Set(id.get(y)), cutsize]; // Yield a small cut with its size\n\n\t\tid.set(x, id.get(x).concat(id.get(y))); // Associate the last vertex with the penultimate one\n\n\t\tH = _contract(H, list(map(([u, _]) => u, ordering))); // Contract all edges between those two vertices\n\t}\n}\n","/**\n * Yields all edges of an undirected unweighted connected loopless multigraph G\n * that have one endpoint inside some vertex subset U and that have the other\n * endpoint inside of V = V(G) \\ U.\n *\n * @param {Map} G The input undirected unweighted connected loopless multigraph.\n * @param {Set} U The subset of edges.\n * @returns {Iterable} The edges of G going from U to V(G) \\ U.\n */\nexport default function* outgoingedges(G, U) {\n\tfor (const u of U) {\n\t\tfor (const v of G.get(u)) {\n\t\t\tif (!U.has(v)) yield [u, v];\n\t\t}\n\t}\n}\n","import adj from '../adj.js';\nimport mb from './mb.js';\nimport outgoingedges from '../outgoingedges.js';\n\n/**\n * Convenience wrapper around Nagamochi-Ibaraki poly-time algorithm.\n *\n * @param {Iterable} edges List of edges of an undirected unweighted connected loopless multigraph G.\n * @returns {Iterable} An iterable over the edges of a minimum cut of G.\n */\nexport default function maxback(edges) {\n\tconst G = adj(edges);\n\tconst [U] = mb(G);\n\treturn outgoingedges(G, U);\n}\n","import {min} from '@iterable-iterator/reduce';\nimport {prop} from '@total-order/key';\nimport {increasing} from '@total-order/primitive';\n\nimport _smallcuts from './_smallcuts.js';\n\n/**\n * Nagamochi-Ibaraki poly-time algorithm.\n *\n * @param {Map} G The adjacency list of an undirected unweighted connected loopless multigraph G.\n * @returns {Array} A pair <code>[U,cutsize]</code> reprensenting a minimum cut of G.\n */\nexport default function mb(G) {\n\treturn min(prop(increasing, 1), _smallcuts(G), undefined);\n}\n"],"names":["adj","edges","G","Map","u","v","has","set","get","push","_contract","ordering","length","H","head","x","n","y","nx","_order","heap","Heap","prop","decreasing","refs","keys","weight","vertex","_iterator2","max","pop","delete","_iterator3","ref","decreasekey","value","_smallcuts","id","size","list","cutsize","Set","concat","map","_context","outgoingedges","U","maxback","min","increasing","undefined","mb"],"mappings":"0kCAOwBA,EAAIC,GAE3B,IADA,MAAMC,EAAI,IAAIC,QACOF,kBAAO,eAAhBG,OAAGC,OACTH,EAAEI,IAAIF,IAAIF,EAAEK,IAAIH,EAAG,IACxBF,EAAEM,IAAIJ,GAAGK,KAAKJ,GACTH,EAAEI,IAAID,IAAIH,EAAEK,IAAIF,EAAG,IACxBH,EAAEM,IAAIH,GAAGI,KAAKL,GAGf,OAAOF,WCNgBQ,EAAUR,EAAGS,GAOpC,IANA,MAAMP,EAAIO,EAASA,EAASC,OAAS,GAC/BP,EAAIM,EAASA,EAASC,OAAS,GAE/BC,EAAI,IAAIV,QAGEW,OAAKH,GAAW,mBAAI,KAAzBI,UACJC,EAAI,GACVH,EAAEN,IAAIQ,EAAGC,GACT,cAAgBd,EAAEM,IAAIO,wBAAXE,UAAeD,EAAEP,KAAKQ,IAAMZ,EAAID,EAAIa,IAGhD,IAAMC,EAAK,GACXL,EAAEN,IAAIH,EAAGc,GAET,cAAgBhB,EAAEM,IAAIJ,wBAAXW,UAAmBA,IAAMV,GAAGa,EAAGT,KAAKM,GAE/C,cAAgBb,EAAEM,IAAIH,wBAAXU,UAAmBA,IAAMX,GAAKW,IAAMV,GAAGa,EAAGT,KAAKM,GAC1D,OAAOF,gCClBiBM,YAAAA,EAAOjB,8GAI/B,IAHMkB,EAAO,IAAIC,cAAKC,OAAKC,aAAY,WACjCC,EAAO,IAAIrB,QAEDD,EAAEuB,uBAAQD,EAAKjB,IAApBF,UAA2Be,EAAKX,KAAK,CAACiB,OAAQ,EAAGC,OAAQtB,KAJtDuB,IAOE1B,uCAGf,OAFM2B,EAAMT,EAAKU,MACX1B,EAAIyB,EAAIF,iBACR,CAACvB,EAAGyB,EAAIH,QAVD,QAWbF,EAAKO,OAAO3B,GAXC4B,IAcG9B,EAAEM,IAAIJ,gDAChBoB,EAAKlB,IADAD,mEAEJ4B,EAAMT,EAAKhB,IAAIH,GAErBe,EAAKc,YAAYD,EAAK,CACrBP,OAAQO,EAAIE,MAAMT,OAAS,EAC3BC,OAAQM,EAAIE,MAAMR,SApBP,oHCEUS,YAAAA,EAAWlC,0GAGnC,IAFIW,EAAIX,EACFmC,EAAK,IAAIlC,QACCD,EAAEuB,uBAAQY,EAAG9B,IAAlBF,UAAyB,CAACA,IAHvB,YAKPQ,EAAEyB,MAAQ,oBAKhB,OAJM3B,EAAW4B,OAAKpB,EAAON,IACtBE,EAAKJ,EAASA,EAASC,OAAS,MAChCK,KAAcN,EAASA,EAASC,OAAS,OAAtC4B,gBAEJ,CAAC,IAAIC,IAAIJ,EAAG7B,IAAIS,IAAKuB,GAVd,OAYbH,EAAG9B,IAAIQ,EAAGsB,EAAG7B,IAAIO,GAAG2B,OAAOL,EAAG7B,IAAIS,KAElCJ,EAAIH,EAAUG,EAAG0B,OAAKI,MAAI,yBAAehC,KAd5BiC,oFCJUC,YAAAA,EAAc3C,EAAG4C,sGACzBA,+CACC5C,EAAEM,IADRJ,uDAEJ0C,EAAExC,IADGD,2BACK,gBAAM,CAACD,EAAGC,GAHb,6FCCS0C,EAAQ9C,GAC/B,IAAMC,EAAIF,EAAIC,GAEd,OAAO4C,EAAc3C,WCDKA,GAC1B,OAAO8C,MAAI1B,OAAK2B,aAAY,GAAIb,EAAWlC,QAAIgD,GDDnCC,CAAGjD"}