{"version":3,"file":"index.modern.js","sources":["../src/adj.js","../src/maxback/_contract.js","../src/maxback/_order.js","../src/maxback/maxback.js","../src/maxback/mb.js","../src/maxback/_smallcuts.js","../src/outgoingedges.js"],"sourcesContent":["/**\n * Constructs the adjacency list for an undirected unweighted connected\n * loopless multigraph G given as a list of edges.\n *\n * @param {Iterable} edges The edges of G.\n * @returns {Map} The adjacency list G.\n */\nexport default function adj(edges) {\n\tconst G = new Map();\n\tfor (const [u, v] of edges) {\n\t\tif (!G.has(u)) G.set(u, []);\n\t\tG.get(u).push(v);\n\t\tif (!G.has(v)) G.set(v, []);\n\t\tG.get(v).push(u);\n\t}\n\n\treturn G;\n}\n","import {head} from '@iterable-iterator/slice';\n\n/**\n * Given G and some ordering, computes the graph H obtained from G by\n * contracting all edges between the last two vertices of the ordering.\n *\n * @param {Map} G\n * @param {Array} ordering\n * @returns {Map}\n */\nexport default function _contract(G, ordering) {\n\tconst u = ordering[ordering.length - 2];\n\tconst v = ordering[ordering.length - 1];\n\n\tconst H = new Map();\n\n\t// Replace each edge xv by the edge xu, x != u ^ x != v\n\tfor (const x of head(ordering, -2)) {\n\t\tconst n = [];\n\t\tH.set(x, n);\n\t\tfor (const y of G.get(x)) n.push(y === v ? u : y);\n\t}\n\n\tconst nx = [];\n\tH.set(u, nx);\n\t// Keep all edges ux with, x != v (x != u is implied because G is loopless)\n\tfor (const x of G.get(u)) if (x !== v) nx.push(x);\n\t// Replace each edge vx by the edge ux, x != u ^ x != v\n\tfor (const x of G.get(v)) if (x !== u && x !== v) nx.push(x);\n\treturn H;\n}\n","import {prop} from '@total-order/key';\nimport {decreasing} from '@total-order/primitive';\nimport {PairingHeap as Heap} from '@heap-data-structure/pairing-heap';\n\n/**\n * Lists the vertices of an undirected unweighted connected loopless multigraph\n * G in max-back order.\n *\n * @param {Map} G The adjacency list of G.\n * @returns {Iterable} The vertices of G in max-back order.\n */\nexport default function* _order(G) {\n\tconst heap = new Heap(prop(decreasing, 'weight'));\n\tconst refs = new Map();\n\n\tfor (const v of G.keys()) refs.set(v, heap.push({weight: 0, vertex: v}));\n\n\t// eslint-disable-next-line no-unused-vars\n\tfor (const _ of G) {\n\t\tconst max = heap.pop();\n\t\tconst u = max.vertex;\n\t\tyield [u, max.weight];\n\t\trefs.delete(u);\n\n\t\t// Update keys\n\t\tfor (const v of G.get(u)) {\n\t\t\tif (!refs.has(v)) continue;\n\t\t\tconst ref = refs.get(v);\n\t\t\t// Max heap so decrease-weight is used for +\n\t\t\theap.decreasekey(ref, {\n\t\t\t\tweight: ref.value.weight + 1,\n\t\t\t\tvertex: ref.value.vertex,\n\t\t\t});\n\t\t}\n\t}\n}\n","import adj from '../adj.js';\nimport mb from './mb.js';\nimport outgoingedges from '../outgoingedges.js';\n\n/**\n * Convenience wrapper around Nagamochi-Ibaraki poly-time algorithm.\n *\n * @param {Iterable} edges List of edges of an undirected unweighted connected loopless multigraph G.\n * @returns {Iterable} An iterable over the edges of a minimum cut of G.\n */\nexport default function maxback(edges) {\n\tconst G = adj(edges);\n\tconst [U] = mb(G);\n\treturn outgoingedges(G, U);\n}\n","import {min} from '@iterable-iterator/reduce';\nimport {prop} from '@total-order/key';\nimport {increasing} from '@total-order/primitive';\n\nimport _smallcuts from './_smallcuts.js';\n\n/**\n * Nagamochi-Ibaraki poly-time algorithm.\n *\n * @param {Map} G The adjacency list of an undirected unweighted connected loopless multigraph G.\n * @returns {Array} A pair <code>[U,cutsize]</code> reprensenting a minimum cut of G.\n */\nexport default function mb(G) {\n\treturn min(prop(increasing, 1), _smallcuts(G), undefined);\n}\n","import {list} from '@iterable-iterator/list';\nimport {map} from '@iterable-iterator/map';\n\nimport _order from './_order.js';\nimport _contract from './_contract.js';\n\n/**\n * Yields the small cuts of undirected unweighted connected loopless multigraph G.\n * At least one of them must be a minimum cut.\n *\n * @param {Map} G The adjacency list of G.\n * @returns {Iterable} The small cuts of G.\n */\nexport default function* _smallcuts(G) {\n\tlet H = G;\n\tconst id = new Map();\n\tfor (const v of G.keys()) id.set(v, [v]);\n\n\twhile (H.size >= 2) {\n\t\tconst ordering = list(_order(H)); // Compute the max-back order\n\t\tconst [x] = ordering[ordering.length - 2];\n\t\tconst [y, cutsize] = ordering[ordering.length - 1];\n\n\t\tyield [new Set(id.get(y)), cutsize]; // Yield a small cut with its size\n\n\t\tid.set(x, id.get(x).concat(id.get(y))); // Associate the last vertex with the penultimate one\n\n\t\tH = _contract(H, list(map(([u, _]) => u, ordering))); // Contract all edges between those two vertices\n\t}\n}\n","/**\n * Yields all edges of an undirected unweighted connected loopless multigraph G\n * that have one endpoint inside some vertex subset U and that have the other\n * endpoint inside of V = V(G) \\ U.\n *\n * @param {Map} G The input undirected unweighted connected loopless multigraph.\n * @param {Set} U The subset of edges.\n * @returns {Iterable} The edges of G going from U to V(G) \\ U.\n */\nexport default function* outgoingedges(G, U) {\n\tfor (const u of U) {\n\t\tfor (const v of G.get(u)) {\n\t\t\tif (!U.has(v)) yield [u, v];\n\t\t}\n\t}\n}\n"],"names":["adj","edges","G","Map","u","v","has","set","get","push","_contract","ordering","length","H","x","head","n","y","nx","_order","heap","Heap","prop","decreasing","refs","keys","weight","vertex","_","max","pop","delete","ref","decreasekey","value","maxback","U","min","increasing","id","size","list","cutsize","Set","concat","map","_smallcuts","undefined","mb","outgoingedges"],"mappings":"iXAOwBA,EAAIC,GAC3B,MAAMC,EAAI,IAAIC,IACd,IAAK,MAAOC,EAAGC,KAAMJ,EACfC,EAAEI,IAAIF,IAAIF,EAAEK,IAAIH,EAAG,IACxBF,EAAEM,IAAIJ,GAAGK,KAAKJ,GACTH,EAAEI,IAAID,IAAIH,EAAEK,IAAIF,EAAG,IACxBH,EAAEM,IAAIH,GAAGI,KAAKL,GAGf,OAAOF,WCNgBQ,EAAUR,EAAGS,GACpC,MAAMP,EAAIO,EAASA,EAASC,OAAS,GAC/BP,EAAIM,EAASA,EAASC,OAAS,GAE/BC,EAAI,IAAIV,IAGd,IAAK,MAAMW,KAAKC,EAAKJ,GAAW,GAAI,CACnC,MAAMK,EAAI,GACVH,EAAEN,IAAIO,EAAGE,GACT,IAAK,MAAMC,KAAKf,EAAEM,IAAIM,GAAIE,EAAEP,KAAKQ,IAAMZ,EAAID,EAAIa,GAGhD,MAAMC,EAAK,GACXL,EAAEN,IAAIH,EAAGc,GAET,IAAK,MAAMJ,KAAKZ,EAAEM,IAAIJ,GAAQU,IAAMT,GAAGa,EAAGT,KAAKK,GAE/C,IAAK,MAAMA,KAAKZ,EAAEM,IAAIH,GAAQS,IAAMV,GAAKU,IAAMT,GAAGa,EAAGT,KAAKK,GAC1D,OAAOD,WClBiBM,EAAOjB,GAC/B,MAAMkB,EAAO,IAAIC,EAAKC,EAAKC,EAAY,WACjCC,EAAO,IAAIrB,IAEjB,IAAK,MAAME,KAAKH,EAAEuB,OAAQD,EAAKjB,IAAIF,EAAGe,EAAKX,KAAK,CAACiB,OAAQ,EAAGC,OAAQtB,KAGpE,IAAK,MAAMuB,KAAK1B,EAAG,CAClB,MAAM2B,EAAMT,EAAKU,MACX1B,EAAIyB,EAAIF,YACR,CAACvB,EAAGyB,EAAIH,QACdF,EAAKO,OAAO3B,GAGZ,IAAK,MAAMC,KAAKH,EAAEM,IAAIJ,GAAI,CACzB,IAAKoB,EAAKlB,IAAID,GAAI,SAClB,MAAM2B,EAAMR,EAAKhB,IAAIH,GAErBe,EAAKa,YAAYD,EAAK,CACrBN,OAAQM,EAAIE,MAAMR,OAAS,EAC3BC,OAAQK,EAAIE,MAAMP,oBCrBEQ,EAAQlC,GAC/B,MAAMC,EAAIF,EAAIC,IACPmC,YCAmBlC,GAC1B,OAAOmC,EAAIf,EAAKgB,EAAY,aCAOpC,GACnC,IAAIW,EAAIX,EACR,MAAMqC,EAAK,IAAIpC,IACf,IAAK,MAAME,KAAKH,EAAEuB,OAAQc,EAAGhC,IAAIF,EAAG,CAACA,IAErC,KAAOQ,EAAE2B,MAAQ,GAAG,CACnB,MAAM7B,EAAW8B,EAAKtB,EAAON,KACtBC,GAAKH,EAASA,EAASC,OAAS,IAChCK,EAAGyB,GAAW/B,EAASA,EAASC,OAAS,QAE1C,CAAC,IAAI+B,IAAIJ,EAAG/B,IAAIS,IAAKyB,GAE3BH,EAAGhC,IAAIO,EAAGyB,EAAG/B,IAAIM,GAAG8B,OAAOL,EAAG/B,IAAIS,KAElCJ,EAAIH,EAAUG,EAAG4B,EAAKI,EAAI,EAAEzC,EAAGwB,KAAOxB,EAAGO,MDdVmC,CAAW5C,QAAI6C,GDDnCC,CAAG9C,GACf,iBGJsCA,EAAGkC,GACzC,IAAK,MAAMhC,KAAKgC,EACf,IAAK,MAAM/B,KAAKH,EAAEM,IAAIJ,GAChBgC,EAAE9B,IAAID,UAAU,CAACD,EAAGC,IHCpB4C,CAAc/C,EAAGkC"}